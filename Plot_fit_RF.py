# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ZW_test.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5 import uic
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.colors import is_color_like, to_hex
from matplotlib.lines import Line2D
from matplotlib.ticker import ScalarFormatter
import sys
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from lmfit import Model, Parameters
from scipy.signal import find_peaks

class UI_main(QtWidgets.QMainWindow):

    def __init__(self):
        super(UI_main, self).__init__()

        # Load the UI file.
        uic.loadUi('Plot_fit_RF.ui',self)

        self.data_loaded = []
        self.data_counter = 0
        self.VoltageFrequencyConstant = 0.3975
        self.lineEdit_VoltageFrequencyConstant.setText(str(self.VoltageFrequencyConstant))

        # Define graph related variables.
        self.PlotLineWidth = 2
        self.ScatterSize = 5
        self.ShowLegend = True
        self.LegendSize = 12
        self.xLimit = [None,None]
        self.xOffset = [0,0]
        self.yLimit = [None,None]
        self.xLabel = 'Laser Detuning [GHz]'
        self.xLabelSize = 18
        self.xTickSize = 18
        self.yLabel = 'Counts [1/second]'
        self.yLabelSize = 18
        self.yTickSize = 18
        self.GraphTitle = 'Graph Title'
        self.GraphTitleSize = 20
        self.AnnotateX = 0.5
        self.AnnotateY = 0.5
        self.AnnotateSize = 14
        self.AspectRatio = ['8:5',UI_main.ConvertAspectRatio('8:5')]

        self.canvas = MatplotlibCanvas()
        self.layout_plot = QtWidgets.QVBoxLayout(self.plotWidget)
        self.layout_plot.addWidget(self.canvas)

        self.pushButton_LoadData.clicked.connect(self.LoadData)
        self.pushButton_EditFileSelection.clicked.connect(self.EditFileSelection)
        self.pushButton_RemoveData.clicked.connect(self.RemoveData)
        self.pushButton_EditFitParameters.clicked.connect(self.EditFitParams)
        self.comboBox_ListDataName.currentIndexChanged.connect(self.UpdateComboBoxSelection)
        self.lineEdit_VoltageFrequencyConstant.editingFinished.connect(self.UpdateVoltageFrequencyConstant)
        self.checkBox_ShowFit.toggled.connect(self.UpdateShowFit)
        self.checkBox_AnnotateLinewidth.toggled.connect(self.UpdateAnnotateLinewidth)
        self.pushButton_SaveFitResult.clicked.connect(self.SaveFitResult)
        self.pushButton_EditGraphParameters.clicked.connect(self.EditGraphParams)
        self.pushButton_SaveGraph.clicked.connect(self.SaveGraph)

        self.show()

    def LoadData(self):
        if hasattr(self, 'LoadData_dialog') and self.LoadData_dialog.isVisible():
            self.LoadData_dialog.raise_()   # Bring the dialog to the front
            return

        if hasattr(self, 'EditData_dialog') or hasattr(self, 'EditFitParams_dialog') or hasattr(self, 'SaveFitResult_dialog') or hasattr(self, 'EditGraphParams_dialog'):
            return

        self.LoadData_dialog = UI_LoadData(self.data_counter)

        if self.LoadData_dialog.exec_() == QtWidgets.QDialog.Accepted:
            # save selected file name and create initial fit.
            accepted_data = self.LoadData_dialog.data_dict
            accepted_data['FitParams'] = self.GuessFitParams(accepted_data)
            accepted_data['FitResult'] = self.FitData(accepted_data)

            self.data_loaded.append(accepted_data)
            self.data_counter += 1
            # Update the combo box with the new loaded data.
            self.comboBox_ListDataName.addItem(accepted_data['DataLabel'])
            self.comboBox_ListDataName.setCurrentIndex(len(self.data_loaded) - 1)

            self.plot_all_data()

        del self.LoadData_dialog

    def EditFileSelection(self):
        # Allow user to update details about the file selected.
        if hasattr(self, 'EditData_dialog') and self.EditData_dialog.isVisible():
            self.EditData_dialog.raise_() # Bring the dialog to the front
            return

        if hasattr(self, 'LoadData_dialog') or hasattr(self, 'EditFitParams_dialog') or hasattr(self, 'SaveFitResult_dialog') or hasattr(self, 'EditGraphParams_dialog'):
            return

        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            self.EditData_dialog = UI_LoadData(self.data_counter,existing_data = self.data_loaded[index], title = 'Edit File Selection')
            if self.EditData_dialog.exec_():
                # When the file is changed, update the data saved and redo the fit.
                Updated_data = self.EditData_dialog.data_dict
                Updated_data['FitParams'] = self.GuessFitParams(Updated_data)
                Updated_data['FitResult'] = self.FitData(Updated_data)
                self.data_loaded[index] = Updated_data
                self.UpdateComboBoxSelection(index)

                self.plot_all_data()

        del self.EditData_dialog

    def RemoveData(self):
        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            self.data_loaded.pop(index)
            self.comboBox_ListDataName.removeItem(index)
            if len(self.data_loaded) == 0:
                self.label_FilePath.setText('Make a selection to display file path here...')
                self.label_VoltageIndex.setText('N/A')
                self.label_CountsIndex.setText('N/A')
                self.label_SkipRows.setText('N/A')
                self.label_PlotColor.setText('N/A')
                self.label_PlotColor.setStyleSheet('')
                self.label_MarkerStyle.setText('N/A')
                self.xLimit = [0,1]
            self.plot_all_data()

    def UpdateComboBoxSelection(self,index):
        if index >= 0 and index < len(self.data_loaded):
            self.label_FilePath.setText(self.data_loaded[index]['FilePath'])
            self.label_VoltageIndex.setText(str(self.data_loaded[index]['VoltageIndex']))
            self.label_CountsIndex.setText(str(self.data_loaded[index]['CountsIndex']))
            self.label_SkipRows.setText(str(self.data_loaded[index]['SkipRows']))
            if self.data_loaded[index]['PlotColor']:
                plot_color = self.data_loaded[index]['PlotColor']
                self.label_PlotColor.setText(plot_color)
                self.label_PlotColor.setStyleSheet(f"color: {plot_color};")
            else:
                self.label_PlotColor.setText('Auto Select')
                self.label_PlotColor.setStyleSheet('')
            if self.data_loaded[index]['MarkerFilled']:
                self.label_MarkerStyle.setText(self.data_loaded[index]['MarkerStyle'] + ' (Filled)')
            else:
                self.label_MarkerStyle.setText(self.data_loaded[index]['MarkerStyle'])
            self.checkBox_ShowFit.setChecked(self.data_loaded[index]['ShowFit'])
            self.checkBox_AnnotateLinewidth.setChecked(self.data_loaded[index]['AnnotateLinewidth'])

    def UpdateShowFit(self,status):
        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            self.data_loaded[index]['ShowFit'] = status
            self.plot_all_data()

    def UpdateAnnotateLinewidth(self,status):
        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            self.data_loaded[index]['AnnotateLinewidth'] = status
            self.plot_all_data()

    def UpdateVoltageFrequencyConstant(self):
        try:
            new_value = float(self.lineEdit_VoltageFrequencyConstant.text())
            self.VoltageFrequencyConstant = new_value

            # Update the plot.
            self.plot_all_data()
        except ValueError:
            QtWidgets.QMessageBox.warning(self, "Invalid Input",
                                          "Voltage to frequency constant must be float.")
            self.lineEdit_VoltageFrequencyConstant.setText(str(self.VoltageFrequencyConstant))
            return

    def EditFitParams(self):
        if hasattr(self, 'EditFitParams_dialog') and self.EditFitParams_dialog.isVisible():
            self.EditFitParams_dialog.raise_() # Bring the dialog to the front
            return

        if hasattr(self, 'LoadData_dialog') or hasattr(self, 'EditData_dialog') or hasattr(self, 'SaveFitResult_dialog') or hasattr(self, 'EditGraphParams_dialog'):
            return

        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            self.EditFitParams_dialog = UI_EditFitParams(ui_main_obj = self,data_dict = self.data_loaded[index])
            if self.EditFitParams_dialog.exec_():
                updated_data = self.EditFitParams_dialog.data_dict
                # Redo the fit.
                updated_data['FitResult'] = self.FitData(updated_data)
                self.data_loaded[index] = updated_data

                self.plot_all_data()

            del self.EditFitParams_dialog

    def SaveFitResult(self):
        if hasattr(self, 'SaveFitResult_dialog') and self.SaveFitResult_dialog.isVisible():
            self.SaveFitResult_dialog.raise_() # Bring the dialog to the front
            return

        if hasattr(self, 'LoadData_dialog') or hasattr(self, 'EditData_dialog') or hasattr(self, 'EditFitParams_dialog') or hasattr(self, 'EditGraphParams_dialog'):
            return

        index = self.comboBox_ListDataName.currentIndex()
        if index >= 0 and index < len(self.data_loaded):
            # Get the fit result
            fit_result = self.data_loaded[index]['FitResult']
            if fit_result:
                # Open the dialog with the fit report
                self.SaveFitResult_dialog = UI_SaveFitResult(fit_result=fit_result)
                self.SaveFitResult_dialog.exec_()
            else:
                QtWidgets.QMessageBox.warning(self, "No Fit Result", "No fit result available for the selected data.")

    def EditGraphParams(self):
        if hasattr(self, 'EditGraphParams_dialog') and self.EditGraphParams_dialog.isVisible():
            self.EditGraphParams_dialog.raise_() # Bring the dialog to the front
            return

        if hasattr(self, 'LoadData_dialog') or hasattr(self, 'EditData_dialog') or hasattr(self, 'EditFitParams_dialog') or hasattr(self, 'SaveFitResult_dialog'):
            return

        self.EditGraphParams_dialog = UI_EditGraphParams(ui_main_obj = self)
        if self.EditGraphParams_dialog.exec_():
            self.PlotLineWidth = self.EditGraphParams_dialog.PlotLineWidth
            self.ScatterSize = self.EditGraphParams_dialog.ScatterSize
            self.ShowLegend = self.EditGraphParams_dialog.ShowLegend
            self.LegendSize = self.EditGraphParams_dialog.LegendSize
            self.xLimit = self.EditGraphParams_dialog.xLimit
            self.xOffset = self.EditGraphParams_dialog.xOffset
            self.yLimit = self.EditGraphParams_dialog.yLimit
            self.xLabel = self.EditGraphParams_dialog.xLabel
            self.xLabelSize = self.EditGraphParams_dialog.xLabelSize
            self.xTickSize = self.EditGraphParams_dialog.xTickSize
            self.yLabel = self.EditGraphParams_dialog.yLabel
            self.yLabelSize = self.EditGraphParams_dialog.yLabelSize
            self.yTickSize = self.EditGraphParams_dialog.yTickSize
            self.GraphTitle = self.EditGraphParams_dialog.GraphTitle
            self.GraphTitleSize = self.EditGraphParams_dialog.GraphTitleSize
            self.AnnotateX = self.EditGraphParams_dialog.AnnotateX
            self.AnnotateY = self.EditGraphParams_dialog.AnnotateY
            self.AnnotateSize = self.EditGraphParams_dialog.AnnotateSize
            self.AspectRatio = self.EditGraphParams_dialog.AspectRatio

            self.plot_all_data()
        del self.EditGraphParams_dialog

    def SaveGraph(self):
        if hasattr(self, 'LoadData_dialog') or hasattr(self, 'EditGraphParams_dialog') or hasattr(self, 'EditData_dialog') or hasattr(self, 'EditFitParams_dialog') or hasattr(self, 'SaveFitResult_dialog'):
            return

        if not len(self.data_loaded) == 0:
            default_fn = self.data_loaded[0]['FilePath'].rstrip('.csv')
            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Save Graph",default_fn,"PNG Files (*.png);;JPEG Files (*.jpg);;TIFF Files (*.tiff)")
            if file_path:  # Proceed if the user provided a file path
                try:
                    # Save the current figure using Matplotlib
                    self.canvas.fig.savefig(file_path, dpi=300, bbox_inches='tight')
                    QtWidgets.QMessageBox.information(self, "Success", f"Graph saved to {file_path}")
                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "Error", f"Failed to save graph: {str(e)}")

    def plot_all_data(self):
        """ Plot all data """
        self.canvas.axes.clear()

        Legend = []
        Annotation = ''

        for index,data in enumerate(self.data_loaded):
            x, y = self.extract_data(data)

            if data['MarkerFilled']:
                ScatterLine, = self.canvas.axes.plot(x-self.xOffset[1],y,data['MarkerStyle'],color = data['PlotColor'],markersize = self.ScatterSize,label = data['DataLabel'])
            else:
                ScatterLine, = self.canvas.axes.plot(x-self.xOffset[1],y,data['MarkerStyle'],color = data['PlotColor'],mfc = 'none',markersize = self.ScatterSize,label = data['DataLabel'])

            if data['ShowFit']:
                LineStyle = '-'
                fmin = np.amin(x)
                fmax = np.amax(x)
                plot_frequencies = np.linspace(fmin,fmax,1000)
                fit_result = data['FitResult']
                self.canvas.axes.plot(plot_frequencies-self.xOffset[1],fit_result.eval(x = plot_frequencies),color = ScatterLine.get_color(),linewidth = self.PlotLineWidth)
            else:
                LineStyle = 'none'

            if data['AnnotateLinewidth']:
                if len(self.data_loaded) == 1:
                    if data['TwoPeaks']:
                        Annotation += (r'$\Gamma_L = {LineWidth_L:1.3f}$ GHz, $\Gamma_R = {LineWidth_R:1.3f}$ GHz'.format(LineWidth_L = data['FitResult'].best_values['fwhm_L'], LineWidth_R = data['FitResult'].best_values['fwhm_R']))
                    else:
                        Annotation += (r'$\Gamma = {LineWidth:1.3f}$ GHz'.format(LineWidth = data['FitResult'].best_values['fwhm']))
                else:
                    if data['TwoPeaks']:
                        Annotation += (data['DataLabel'] + r': $\Gamma_L = {LineWidth_L}$ GHz, $\Gamma_R = {LineWidth_R}$ GHz\n'.format(LineWidth_L = data['FitResult'].best_values['fwhm_L'], LineWidth_R = data['FitResult'].best_values['fwhm_R']))
                        Annotation += '\n'
                    else:
                        Annotation += (data['DataLabel'] + r': $\Gamma = {LineWidth:1.3f}$ GHz'.format(LineWidth = data['FitResult'].best_values['fwhm']))
                        Annotation += '\n'

            Legend.append(Line2D([0], [0], color=ScatterLine.get_color(), marker=data['MarkerStyle'],mfc = ScatterLine.get_markerfacecolor(), linestyle=LineStyle, label=data['DataLabel']))

        if self.ShowLegend and not len(self.data_loaded) == 0:
            self.canvas.axes.legend(handles=Legend, fontsize=self.LegendSize)

        if not Annotation == '':
            self.canvas.axes.annotate(Annotation,xy = (self.AnnotateX,self.AnnotateY),fontsize = self.AnnotateSize,xycoords ='axes fraction')

        self.canvas.axes.set_title(self.GraphTitle, fontsize=self.GraphTitleSize)
        self.canvas.axes.set_xlim(self.xLimit)
        self.canvas.axes.set_xlim(self.yLimit)
        self.canvas.axes.set_xlabel(self.xLabel, fontsize = self.xLabelSize)
        self.canvas.axes.set_ylabel(self.yLabel, fontsize = self.yLabelSize)
        self.canvas.axes.tick_params(axis='x', labelsize=self.xTickSize)
        self.canvas.axes.tick_params(axis='y', labelsize=self.yTickSize)

        formatter = ScalarFormatter(useMathText=True)
        formatter.set_scientific(True)
        formatter.set_powerlimits((-2, 3))
        self.canvas.axes.yaxis.set_major_formatter(formatter)
        self.canvas.axes.yaxis.get_offset_text().set_fontsize(self.yTickSize)

        self.resize_canvas_to_fit(self.AspectRatio[1])
        self.canvas.axes.set_box_aspect(1/self.AspectRatio[1])
        self.canvas.update_layout()
        self.canvas.draw()

    def extract_data(self,data):
        try:
            # Load the data file
            df = pd.read_csv(data['FilePath'], skiprows=data['SkipRows'])

            # Extract the columns
            voltage = df.iloc[:, data['VoltageIndex']].to_numpy()
            counts = df.iloc[:, data['CountsIndex']].to_numpy()
            frequency = self.Toptica_V_to_GHz(voltage)

            return frequency,counts
        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self, "Error Loading Data", f"An error occurred when reading CSV file: {str(e)}\nPlease load data again."
            )
            self.RemoveData()
            return

    def GuessFitParams(self, data_dict):
        Frequencies, Counts = self.extract_data(data_dict)

        fit_params = dict()

        fit_params['PeakFrequency'] = Frequencies[np.argmax(Counts)]
        fit_params['Linewidth'] = 1  # Start with 1 GHz linewidth
        fit_params['PeakCounts'] = int(np.amax(Counts))
        fit_params['Background'] = int(np.amin(Counts))
        fit_params['FitRange'] = [Frequencies[0], Frequencies[-1]]  # Initially fit the entire data range.

        return fit_params

    def UpdateFitParams(self, data_dict):
        Frequencies, Counts = self.extract_data(data_dict)

        fit_params = dict()

        fit_params['FitRange'] = data_dict['FitParams']['FitRange']
        fit_params['Background'] = data_dict['FitParams']['Background']

        if data_dict['TwoPeaks']:
            PeakCounts = np.amax(Counts)
            peaks, _ = find_peaks(Counts, height=PeakCounts*0.6)

            fit_params['PeakFrequency_L'] = Frequencies[peaks[0]]
            fit_params['PeakFrequency_R'] = Frequencies[peaks[1]]
            fit_params['Linewidth_L'] = 1  # Start with 1 GHz linewidth
            fit_params['Linewidth_R'] = 1  # Start with 1 GHz linewidth
            fit_params['PeakCounts_L'] = int(Counts[peaks[0]])
            fit_params['PeakCounts_R'] = int(Counts[peaks[1]])
        else:
            fit_params['PeakFrequency'] = Frequencies[np.argmax(Counts)]
            fit_params['Linewidth'] = 1  # Start with 1 GHz linewidth
            fit_params['PeakCounts'] = int(np.amax(Counts))

        return fit_params

    def FitData(self, data_dict):
        Frequencies, Counts = self.extract_data(data_dict)

        # Cut data to meet fit range setting.
        fmin,fmax = data_dict['FitParams']['FitRange']
        Filter = (Frequencies >= fmin) & (Frequencies <= fmax)
        FitFrequency = Frequencies[Filter]
        FitCounts = Counts[Filter]

        if data_dict['TwoPeaks']:
            fit_model = Model(UI_main.two_lorentzian)

            params = Parameters()
            params.add('x0_L', value=data_dict['FitParams']['PeakFrequency_L'])
            params.add('x0_R', value=data_dict['FitParams']['PeakFrequency_R'])
            params.add('a_L',
                       value=data_dict['FitParams']['PeakCounts_L'] * np.pi * data_dict['FitParams']['Linewidth_L'] / 2,
                       min=0)
            params.add('a_R',
                       value=data_dict['FitParams']['PeakCounts_R'] * np.pi * data_dict['FitParams']['Linewidth_R'] / 2,
                       min=0)
            params.add('fwhm_L', value=data_dict['FitParams']['Linewidth_L'], min=0)
            params.add('fwhm_R', value=data_dict['FitParams']['Linewidth_R'], min=0)
            params.add('BKG', value=data_dict['FitParams']['Background'], min=0)

            result = fit_model.fit(FitCounts, x=FitFrequency, params=params)

            return result
        else:
            fit_model = Model(UI_main.lorentzian)

            params = Parameters()
            params.add('x0', value=data_dict['FitParams']['PeakFrequency'])
            params.add('a', value=data_dict['FitParams']['PeakCounts']*np.pi*data_dict['FitParams']['Linewidth']/2, min=0)
            params.add('fwhm', value=data_dict['FitParams']['Linewidth'], min=0)
            params.add('BKG', value=data_dict['FitParams']['Background'],min = 0)

            result = fit_model.fit(FitCounts, x=FitFrequency, params=params)

            return result

    @staticmethod
    def ConvertAspectRatio(aspect_ratio_text):
        width, height = map(float, aspect_ratio_text.split(":"))
        aspect_ratio = width / height
        return aspect_ratio

    def resize_canvas_to_fit(self, aspect_ratio):
        """Resize the canvas to fit the parent widget while maintaining the aspect ratio."""
        widget_width = self.plotWidget.width()
        widget_height = self.plotWidget.height()

        # Calculate the maximum size within the widget bounds
        if widget_width / widget_height > aspect_ratio:
            # Constrain by height
            new_width = int(widget_height * aspect_ratio)
            new_height = widget_height
        else:
            # Constrain by width
            new_width = widget_width
            new_height = int(widget_width / aspect_ratio)

        self.canvas.setFixedSize(new_width, new_height)

    def Toptica_V_to_GHz(self,V_toptica, V_ref=70):
        return (V_toptica - V_ref) * self.VoltageFrequencyConstant

    @staticmethod
    def lorentzian(x, x0, a, fwhm, BKG):
        return a / np.pi * (fwhm / 2) / ((x - x0) ** 2 + (fwhm / 2) ** 2) + BKG

    @staticmethod
    def two_lorentzian(x, x0_L, x0_R, a_L, a_R, fwhm_L,fwhm_R, BKG):  # L = "left", R = "right"
        return UI_main.lorentzian(x, x0_L, a_L, fwhm_L, 0) + UI_main.lorentzian(x, x0_R, a_R, fwhm_R, 0) + BKG

class UI_LoadData(QtWidgets.QDialog):
    def __init__(self, num_data,existing_data = None, title = 'Load Data'):
        super(UI_LoadData, self).__init__()

        # Load the UI file.
        uic.loadUi('Load_data.ui', self)

        self.setWindowTitle(title)

        # Initialize an empty dict object to store the data.
        self.data_dict = dict()
        self.data_number = num_data + 1

        if existing_data:
            self.label_filepath.setText(existing_data['FilePath'])
            self.lineEdit_VoltageIndex.setText(str(existing_data['VoltageIndex']))
            self.lineEdit_CountsIndex.setText(str(existing_data['CountsIndex']))
            self.lineEdit_SkipRows.setText(str(existing_data['SkipRows']))
            self.lineEdit_DataLabel.setText(existing_data['DataLabel'])
            self.lineEdit_MarkerStyle.setText(existing_data['MarkerStyle'])
            if existing_data['PlotColor']:
                self.lineEdit_PlotColor.setText(existing_data['PlotColor'])
            self.checkBox_MarkerFilled.setChecked(existing_data['MarkerFilled'])
        else:
            self.lineEdit_DataLabel.setText('Data_' + str(self.data_number))
            self.lineEdit_VoltageIndex.setText('0')
            self.lineEdit_CountsIndex.setText('2')
            self.lineEdit_SkipRows.setText('0')
            self.lineEdit_MarkerStyle.setText('o')
            self.checkBox_MarkerFilled.setChecked(False)

        self.label_filepath.setWordWrap(True)
        self.pushButton_Selectfile.clicked.connect(self.selectFile)
        self.toolButton_SelectColor.clicked.connect(self.selectColor)
        self.buttonBox_accept.accepted.connect(self.accept_input)

        self.show()

    def selectFile(self):
        fpath = QtWidgets.QFileDialog.getOpenFileName(self, 'Open File', 'C:/Users/znw11/Documents/Zixuan/Optical_data/', 'Comma-separated values (*.csv)')

        if fpath[0]:
            self.label_filepath.setText(fpath[0])

    def selectColor(self):
        color = QtWidgets.QColorDialog.getColor()
        if color.isValid():
            self.lineEdit_PlotColor.setText(color.name())

    def accept_input(self):
        file_path = self.label_filepath.text().strip()
        if file_path == 'FilePath':
            file_path = None

        # Check if a valid file path is provided
        if not file_path:
            QtWidgets.QMessageBox.warning(self, "No File Selected",
                                          "Please select a file to load.")
            self.reject()
            return

        # Ensure the file is a CSV
        if not file_path.lower().endswith('.csv'):
            QtWidgets.QMessageBox.warning(self, "Invalid File",
                                          "Only .csv files are allowed.")
            self.reject()
            return

        self.data_dict['FilePath'] = self.label_filepath.text()
        self.data_dict['DataLabel'] = self.lineEdit_DataLabel.text()

        try:
            self.data_dict['VoltageIndex'] = int(self.lineEdit_VoltageIndex.text())
            self.data_dict['CountsIndex'] = int(self.lineEdit_CountsIndex.text())
            self.data_dict['SkipRows'] = int(self.lineEdit_SkipRows.text())
        except ValueError:
            QtWidgets.QMessageBox.warning(self, "Invalid Input",
                                          "Voltage Index, Counts Index, and Skip Rows must be integers.")
            self.reject()
            return

        color_input = self.lineEdit_PlotColor.text().strip()
        if color_input and not is_color_like(color_input):
            QtWidgets.QMessageBox.warning(self, "Invalid Color",
                                          "Please enter a valid color (e.g., #RRGGBB, rgb(r,g,b), or a named color).")
            self.reject()
            return
        self.data_dict['PlotColor'] = color_input if color_input else None

        marker_input = self.lineEdit_MarkerStyle.text().strip()
        if marker_input not in Line2D.markers:
            QtWidgets.QMessageBox.warning(self, "Invalid Marker",
                                          f"'{marker_input}' is not a valid marker. Refer to Matplotlib documentation for valid markers.")
            self.reject()
            return
        self.data_dict['MarkerStyle'] = marker_input
        self.data_dict['MarkerFilled'] = self.checkBox_MarkerFilled.isChecked()

        self.data_dict['ShowFit'] = False
        self.data_dict['AnnotateLinewidth'] = False

        # Initialize the data dict as single peak data (i.e., No FSS).
        self.data_dict['TwoPeaks'] = False

        self.accept()

class UI_EditFitParams(QtWidgets.QDialog):
    def __init__(self,ui_main_obj, data_dict):
        super(UI_EditFitParams, self).__init__()
        # Load the UI file.
        uic.loadUi('Edit_fit_params.ui', self)

        self.setWindowTitle('Edit Fit Parameters')
        self.ui_main_obj = ui_main_obj
        self.data_dict = data_dict

        self.checkBox_TwoPeaks.setChecked(self.data_dict['TwoPeaks'])
        self.lineEdit_fCenterR.setEnabled(self.data_dict['TwoPeaks'])
        self.lineEdit_LineWidthR.setEnabled(self.data_dict['TwoPeaks'])
        self.lineEdit_AmplitudeR.setEnabled(self.data_dict['TwoPeaks'])

        if self.data_dict['TwoPeaks']:
            self.lineEdit_fCenterL.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency_L'],decimals=3)))
            self.lineEdit_fCenterR.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency_R'],decimals=3)))
            self.lineEdit_LineWidthL.setText(str(np.round(self.data_dict['FitParams']['Linewidth_L'],decimals = 3)))
            self.lineEdit_LineWidthR.setText(str(np.round(self.data_dict['FitParams']['Linewidth_R'],decimals = 3)))
            self.lineEdit_AmplitudeL.setText(str(int(self.data_dict['FitParams']['PeakCounts_L'])))
            self.lineEdit_AmplitudeR.setText(str(int(self.data_dict['FitParams']['PeakCounts_R'])))
        else:
            self.lineEdit_fCenterL.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency'], decimals=3)))
            self.lineEdit_LineWidthL.setText(str(np.round(self.data_dict['FitParams']['Linewidth'], decimals=3)))
            self.lineEdit_AmplitudeL.setText(str(int(self.data_dict['FitParams']['PeakCounts'])))

        self.lineEdit_FitRangeLow.setText(str(np.round(self.data_dict['FitParams']['FitRange'][0], decimals = 4)))
        self.lineEdit_FitRangeHigh.setText(str(np.round(self.data_dict['FitParams']['FitRange'][1], decimals = 4)))
        self.lineEdit_Background.setText(str(int(self.data_dict['FitParams']['Background'])))

        self.checkBox_TwoPeaks.toggled.connect(self.ChangeTwoPeaks)
        self.buttonBox.accepted.connect(self.accept_input)

        self.show()

    def ChangeTwoPeaks(self):
        self.data_dict['TwoPeaks'] = self.checkBox_TwoPeaks.isChecked()
        try:
            self.data_dict['FitParams'] = self.ui_main_obj.UpdateFitParams(data_dict=self.data_dict)
        except Exception as e:
            self.data_dict['TwoPeaks'] = not self.checkBox_TwoPeaks.isChecked()
            QtWidgets.QMessageBox.warning(
                self,
                "Error Updating Fit Parameters",
                f"An error occurred while updating fit parameters: {str(e)}"
            )
            return

        self.lineEdit_fCenterR.setEnabled(self.data_dict['TwoPeaks'])
        self.lineEdit_LineWidthR.setEnabled(self.data_dict['TwoPeaks'])
        self.lineEdit_AmplitudeR.setEnabled(self.data_dict['TwoPeaks'])

        if self.data_dict['TwoPeaks']:
            self.lineEdit_fCenterL.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency_L'], decimals=3)))
            self.lineEdit_fCenterR.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency_R'], decimals=3)))
            self.lineEdit_LineWidthL.setText(str(np.round(self.data_dict['FitParams']['Linewidth_L'], decimals=3)))
            self.lineEdit_LineWidthR.setText(str(np.round(self.data_dict['FitParams']['Linewidth_R'], decimals=3)))
            self.lineEdit_AmplitudeL.setText(str(int(self.data_dict['FitParams']['PeakCounts_L'])))
            self.lineEdit_AmplitudeR.setText(str(int(self.data_dict['FitParams']['PeakCounts_R'])))
        else:
            self.lineEdit_fCenterL.setText(str(np.round(self.data_dict['FitParams']['PeakFrequency'], decimals=3)))
            self.lineEdit_LineWidthL.setText(str(np.round(self.data_dict['FitParams']['Linewidth'], decimals=3)))
            self.lineEdit_AmplitudeL.setText(str(int(self.data_dict['FitParams']['PeakCounts'])))
            self.lineEdit_fCenterR.setText(None)
            self.lineEdit_LineWidthR.setText(None)
            self.lineEdit_AmplitudeR.setText(None)

    def accept_input(self):
        fit_params = dict()
        try:
            fit_params['FitRange'] = [float(self.lineEdit_FitRangeLow.text()),float(self.lineEdit_FitRangeHigh.text())]
            fit_params['Background'] = int(self.lineEdit_Background.text())
            if self.data_dict['TwoPeaks']:
                fit_params['PeakFrequency_L'] = float(self.lineEdit_fCenterL.text())
                fit_params['PeakFrequency_R'] = float(self.lineEdit_fCenterR.text())
                fit_params['Linewidth_L'] = float(self.lineEdit_LineWidthL.text())
                fit_params['Linewidth_R'] = float(self.lineEdit_LineWidthR.text())
                fit_params['PeakCounts_L'] = int(self.lineEdit_AmplitudeL.text())
                fit_params['PeakCounts_R'] = int(self.lineEdit_AmplitudeR.text())
            else:
                fit_params['PeakFrequency'] = float(self.lineEdit_fCenterL.text())
                fit_params['Linewidth'] = float(self.lineEdit_LineWidthL.text())
                fit_params['PeakCounts'] = int(self.lineEdit_AmplitudeL.text())
        except ValueError:
            QtWidgets.QMessageBox.warning(self, "Invalid Input",
                                            "Invalid input for fit parameters.")
            self.reject()
            return
        except Exception as e:
            print(f"Unexpected error: {e}")
            self.reject()

        self.data_dict['FitParams'] = fit_params
        self.accept()

class UI_SaveFitResult(QtWidgets.QDialog):
    def __init__(self, fit_result):
        super(UI_SaveFitResult, self).__init__()
        # Load the UI file.
        uic.loadUi('Save_fit_result.ui', self)
        self.fit_result = fit_result

        # Set up the dialog UI
        self.setWindowTitle("Fit Result")

        # Text box for the fit report
        self.plainTextEdit_FitResult.setReadOnly(True)
        self.plainTextEdit_FitResult.setPlainText(self.fit_result.fit_report())

        # Save button
        self.pushButton_SaveResult.clicked.connect(self.save_as_txt)

    def save_as_txt(self):
        # Open a file dialog to save the text file
        save_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Fit Result", "", "Text Files (*.txt)")
        if save_path:
            try:
                with open(save_path, 'w') as f:
                    f.write(self.fit_result.fit_report())
                QtWidgets.QMessageBox.information(self, "Success", "Fit result saved successfully.")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Could not save file: {str(e)}")

class UI_EditGraphParams(QtWidgets.QDialog):
    def __init__(self,ui_main_obj):
        super(UI_EditGraphParams, self).__init__()
        # Load the UI file.
        uic.loadUi('Edit_graph_params.ui', self)

        self.setWindowTitle('Edit Graph Parameters')
        self.ui_main_obj = ui_main_obj

        self.comboBox_ListDataName.addItem('None')
        for data in self.ui_main_obj.data_loaded:
            self.comboBox_ListDataName.addItem(data['DataLabel'])
        self.comboBox_ListDataName.setCurrentIndex(self.ui_main_obj.xOffset[0])

        self.lineEdit_PlotLinewidth.setText(str(self.ui_main_obj.PlotLineWidth))
        self.lineEdit_ScatterSize.setText(str(self.ui_main_obj.ScatterSize))
        self.checkBox_ShowLegend.setChecked(self.ui_main_obj.ShowLegend)
        self.lineEdit_LegendSize.setText(str(self.ui_main_obj.LegendSize))
        self.lineEdit_XLabel.setText(self.ui_main_obj.xLabel)
        self.lineEdit_XLabelSize.setText(str(self.ui_main_obj.xLabelSize))
        self.lineEdit_XTickSize.setText(str(self.ui_main_obj.xTickSize))
        self.lineEdit_YLabel.setText(self.ui_main_obj.yLabel)
        self.lineEdit_YLabelSize.setText(str(self.ui_main_obj.yLabelSize))
        self.lineEdit_YTickSize.setText(str(self.ui_main_obj.yTickSize))
        if self.ui_main_obj.xLimit[0] == None:
            self.lineEdit_XLimitLow.setText('')
        else:
            self.lineEdit_XLimitLow.setText(str(self.ui_main_obj.xLimit[0]))
        if self.ui_main_obj.xLimit[1] == None:
            self.lineEdit_XLimitHigh.setText('')
        else:
            self.lineEdit_XLimitHigh.setText(str(self.ui_main_obj.xLimit[1]))

        if self.ui_main_obj.yLimit[0] == None:
            self.lineEdit_YLimitLow.setText('')
        else:
            self.lineEdit_YLimitLow.setText(str(self.ui_main_obj.yLimit[0]))
        if self.ui_main_obj.yLimit[1] == None:
            self.lineEdit_YLimitHigh.setText('')
        else:
            self.lineEdit_YLimitHigh.setText(str(self.ui_main_obj.yLimit[1]))
        self.lineEdit_GraphTitle.setText(self.ui_main_obj.GraphTitle)
        self.lineEdit_GraphTitleSize.setText(str(self.ui_main_obj.GraphTitleSize))
        self.lineEdit_AnnotationX.setText(str(self.ui_main_obj.AnnotateX))
        self.lineEdit_AnnotationY.setText(str(self.ui_main_obj.AnnotateY))
        self.lineEdit_AnnotationSize.setText(str(self.ui_main_obj.AnnotateSize))
        self.lineEdit_GraphAspectRatio.setText(self.ui_main_obj.AspectRatio[0])

        self.checkBox_ShowLegend.toggled.connect(self.ChangeShowLegend)
        self.buttonBox.accepted.connect(self.accept_input)

        self.show()

    def ChangeShowLegend(self):
        self.lineEdit_LegendSize.setEnabled(self.checkBox_ShowLegend.isChecked())

    def accept_input(self):
        index = self.comboBox_ListDataName.currentIndex()
        self.xOffset = [0,0]
        if index >= 0 and index < (len(self.ui_main_obj.data_loaded) + 1):
            self.xOffset[0] = index
            if index == 0:
                self.xOffset[1] = 0
            else:
                if self.ui_main_obj.data_loaded[index-1]['TwoPeaks']:
                    self.xOffset[1] = self.ui_main_obj.data_loaded[index - 1]['FitResult'].best_values['x0_L']
                else:
                    self.xOffset[1] = self.ui_main_obj.data_loaded[index - 1]['FitResult'].best_values['x0']
        else:
            QtWidgets.QMessageBox.warning(self, "Invalid Data Selection",
                                          "Invalid selection for reference data.")
            self.reject()
            return
        self.ShowLegend = self.checkBox_ShowLegend.isChecked()
        self.xLabel = r'{}'.format(self.lineEdit_XLabel.text())
        self.yLabel = r'{}'.format(self.lineEdit_YLabel.text())
        self.GraphTitle = r'{}'.format(self.lineEdit_GraphTitle.text())
        try:
            self.PlotLineWidth = float(self.lineEdit_PlotLinewidth.text())
            self.ScatterSize = float(self.lineEdit_ScatterSize.text())
            self.LegendSize = float(self.lineEdit_LegendSize.text())
            self.xLabelSize = float(self.lineEdit_XLabelSize.text())
            self.xTickSize = float(self.lineEdit_XTickSize.text())
            self.yLabelSize = float(self.lineEdit_YLabelSize.text())
            self.yTickSize = float(self.lineEdit_YTickSize.text())
            self.xLimit = [None,None]
            self.yLimit = [None,None]
            if not self.lineEdit_XLimitLow.text() == '':
                self.xLimit[0] = float(self.lineEdit_XLimitLow.text())
            if not self.lineEdit_XLimitHigh.text() == '':
                self.xLimit[1] = float(self.lineEdit_XLimitHigh.text())
            if not self.lineEdit_YLimitLow.text() == '':
                self.yLimit[0] = float(self.lineEdit_YLimitLow.text())
            if not self.lineEdit_YLimitHigh.text() == '':
                self.yLimit[1] = float(self.lineEdit_YLimitHigh.text())
            self.GraphTitleSize = float(self.lineEdit_GraphTitleSize.text())
            self.AnnotateX = float(self.lineEdit_AnnotationX.text())
            self.AnnotateY = float(self.lineEdit_AnnotationY.text())
            self.AnnotateSize = float(self.lineEdit_AnnotationSize.text())
        except ValueError:
            QtWidgets.QMessageBox.warning(self, "Invalid Input",
                                            "Invalid input for graph parameters.")
            self.reject()
            return
        except Exception as e:
            print(f"Unexpected error: {e}")
            self.reject()
            return

        try:
            self.AspectRatio = [0,0]
            self.AspectRatio[0] = self.lineEdit_GraphAspectRatio.text()
            width, height = map(float, self.AspectRatio[0].split(":"))
            aspect_ratio = width / height
            self.AspectRatio[1] = aspect_ratio
        except ValueError:
            QtWidgets.QMessageBox.warning(self, "Invalid Input",
                                          "Please enter aspect ratio in the format 'width:height' (e.g., 16:9).")
            self.reject()
            return

        self.accept()

class MatplotlibCanvas(FigureCanvas):
    def __init__(self):
        # Create a Matplotlib figure and axes
        self.fig = Figure()
        self.axes = self.fig.add_subplot()
        super(MatplotlibCanvas, self).__init__(self.fig)

    def update_layout(self):
        """Update the layout of the figure to fit the canvas."""
        self.fig.tight_layout()

if __name__ == "__main__":

    app = QtWidgets.QApplication(sys.argv)
    UiWindow = UI_main()
    app.exec_()
